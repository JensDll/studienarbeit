\chapter{Das RSA-Kryptosystem} \label{cha:rsa}
Das RSA-Kryptosystem ist eines der bekanntesten und meist
verbreiteten asymmetrischen Verschlüsselungsverfahren. Es ist benannt nach
seinen drei Erfindern Ronald Rivest, Adi Shamir und Leonard Adleman, welche das Verfahren
im Jahr 1977 veröffentli\-chten \parencite[173]{BOOK:crypto}.
Am Beispiel von RSA sollen in diesem Kapitel die
Ideen der asymmetrischen Verschlüsselung
(engl. \textit{public-key-crpytography} oder \textit{asymmetric crpytography})
vorgestellt werden. Es werden die nötigen
zahlentheoretischen Begriffe eingeführt, um nachzuvollziehen
warum die RSA-Verschlüsselung funktioniert und sicher ist.

\section{Asymmetrische Verschlüsselung}
Um die Idee der asymmetrischen Verschlüsselung besser zu verstehen,
ist es hilfreich auf das Prinzip der symmetrischen Verfahren zurückzukommen
(\autoref{fig:sym-encryption-revisit}).

\input{chapters/rsa/tikz/sym-encryption.tex}

\noindent
Ein solches System hat zwei symmetrische Eigenschaften:
\begin{enumerate}
  \item Derselbe geheime Schlüssel wird sowohl für die
        Verschlüsselung als auch Entschlüs\-selung verwendet.
  \item Die Ver- und Entschlüsselungsfunktion sind sich sehr ähnlich
        (im Fall von \acs{otp} oder \acs{des} sind sie sogar gleich).
\end{enumerate}
Verfahren wie \acs{aes} sind sehr sicher und schnell.
Ihre symmetrischen Eigenschaften führen jedoch auch zu Problemen
und Einschränkungen,
welche im Folgenden beschrieben werden:

\paragraph{Schlüsselverteilungsproblem}
Da beide Parteien denselben Schlüssel benötigen, muss dieser in
irgendeiner Form untereinander verteilt werden.
Der direkte Austausch über die Schnittstelle ist nicht möglich, denn
die öffentliche Kommunikationsstrecke (unsicherer Kanal) ist nicht geschützt gegen Abhören.

\paragraph{Anzahl der Schlüssel}
Auch wenn das Schlüsselverteilungsproblem gelöst werden kann, entstehen
schnell Probleme, da die Anzahl der Schlüssel in einem
Netz mit zunehmender Teilnehmerzahl stark wächst. In einem Netz mit $n$
Teilnehmern, wobei jeder Teilnehmer mit jedem verschlüsselt kommunizieren soll, gibt es
\begin{equation*}
  \binom{n}{2} = \frac{n!}{2! \cdot (n-2)!} = \frac{n\cdot(n-1)}{2} \approx \frac{n^2}{2}
\end{equation*}
verschiedene Schlüsselpaare und jeder Teilnehmer muss $n-1$ Schlüssel speichern.
\begin{example}
  In einem Netz mit 500 Teilnehmern gibt es bereits $500 \cdot 499 / 2 = 124.750$ Schlüsselpaare
  und $124.750 \cdot 2 = 249.500$ Schlüssel müssen verteilt werden.
\end{example}
\noindent
Das Problem ist auch bekannt als das
$n^2$-Schlüsselverteilungsproblem \parencite[334-335]{BOOK:crypto}.

\paragraph{Verbindlichkeit}
Es ist nur mit symmetrischer Verschlüsselung nicht möglich, einer dritten Person
zu beweisen, welcher Gesprächsteilnehmer eine Nachricht erstellt hat.
Es gibt jedoch viele Bereiche, in denen dieser Beweis wichtig ist, beispielsweise
im Onlinehandel:
\begin{example}
  Alice betreibt einen Onlinehandel, sie muss beweisen können, dass ein
  Käufer Bob eine Bestellung getätigt hat,
  denn anderenfalls könnte er jederzeit behaupten,
  Alice hätte diese fälschlicherweise erstellt.
\end{example}
\noindent
Das Problem ist auch bekannt als Non-Repudiation \parencite{SITE:nonrepudiation}
und kann gelöst werden durch digitale Signaturen.\\

\noindent
Asymmetrische Verschlüsselungsverfahren bieten mögliche Lösungen zu den eben
beschriebenen Problemen, um eine Nachricht zu verschlüsseln, ist es nicht mehr nötig,
dass der Absender in Besitz von geheimer Information ist. Solch ein System wird
realisiert, indem Bob einen Schlüssel veröffentlicht,
welcher jedem Netzteilnehmer
zur Verfügung steht und frei verwendet werden kann.
Bob hat außerdem einen privaten Schlüssel, welchen nur er kennt.
Bobs Schlüssel $k$ besteht also aus einem öffentlichen Teil, $\keypub{}$ (\textit{key public}),
und einem privaten Teil, $\keypr{}$ (\textit{key private}). Wichtig ist, dass eine Nachricht,
welche mit Bobs öffentlichen Schlüssel verschlüsselt wurde, nur auch mit Bobs privaten
Schlüssel wieder entschlüsselt werden kann. Ein einfaches Protokoll,
welches nach diesem Prinzip arbeitet ist in \autoref{fig:asym-encr} zu sehen.

\input{chapters/rsa/tikz/asym-encryption.tex}

\noindent
Ein Nachrichtenaustausch ist somit ohne sicheren Kanal möglich. Der oben beschriebene
Ablauf kann nun so modifiziert, um einen symmetrischen Schlüssel auszutauschen, beispielsweise
für \acs{aes}. Alice generiert einen symmetrischen Schlüssel und verschlüsselt ihn mit einem
asymmetrischen Verfahren. Bob kann die Nachricht entschlüsseln und ist somit ebenfalls
im Besitz des Schlüssels. Wie in \autoref{fig:asym-encr-key-exchange} zu sehen ist,
kann die restliche Kommunikation jetzt mit einem symmetrischen
Verfahren gesichert werden. Es ist durchaus wünschenswert, nicht dauerhaft asymmetrisch
zu verschlüsseln, da dies im Gegensatz zu dem symmetrischen Gegenstück sehr viel
rechenintensiver ist.
\newpage

\input{chapters/rsa/tikz/asym-encrpytion-key.tex}

\noindent
Asymmetrische Verfahren basieren alle auf einem zugrunde liegenden Prinzip:
Der Einwegfunktion oder auch Falltürfunktion genannt. Es kann folgende
Definition gegeben werden \parencite[153]{BOOK:crypto}:

\begin{definition}[Einwegfunktion]
  Eine Funktion $f$ heißt Einwegfunktion, wenn gilt:
  \begin{enumerate}
    \item Der Funktionswert $y = f(x)$ ist komplexitätstheoretisch einfach berechenbar,
          d.\,h. die Laufzeit des Algorithmus wächst
          nicht stärker als eine Polynomfunktion (Polynomialzeit).
    \item Die Umkehrfunktion $x = f^{-1}(y)$ ist komplexitätstheoretisch schwierig berechenbar,
          d.\,h. es gibt keinen bekannten Algorithmus welcher das Problem in angemessener
          Zeit lösen kann, zum Beispiel in 1000 Jahren.
  \end{enumerate}
\end{definition}

\noindent
Es gibt zwei Einwegfunktionen, welche in der Praxis häufig eingesetzt werden.
Die erste Funktion, welche auch in RSA verwendet wird,
basiert auf dem Faktorisieren großer natürlicher Zahlen.
Es ist einfach ein Produkt zu berechnen, jedoch ist es schwierig, eine Zahl zu
faktorisieren. Die zweite Funktion basiert auf dem Lösen diskreter Logarithmen.
Das Berechnen diskreter Logarithmen ist ein rechenintensives Problem
und bildet unter anderem die Einwegfunktion des
Diffie-Hellman-Schlüsselaustausches.
Das gesamte Verfahren hat jedoch keine so intuitive Beschreibung.

\section{Zahlentheoretische Grundlagen}
Es werden in diesem Abschnitt die zahlentheoretischen Grundlagen beschrieben,
um nachzuvollziehen warum die RSA-Verschlüsselung funktioniert.

\input{chapters/rsa/zahlentheorie/euklid.tex}

\input{chapters/rsa/zahlentheorie/phi-funktion.tex}

\input{chapters/rsa/zahlentheorie/euler-fermat.tex}

\section{Das RSA-Verfahren}
Das RSA-Verfahren basiert auf der Annahme, dass es nicht effizient
möglich ist, die Primfaktorzerlegung einer natürlichen Zahl zu bestimmen.
Die Generierung des privaten und öffentlichen Schlüssels kann in die
folgenden fünf Schritte unterteilt werden \parencite[176]{BOOK:crypto}:
\newpage
\begin{definition}[RSA Schlüsselgenerierung]\mbox{}
  \begin{enumerate}
    \item Wähle zwei sehr große Primzahlen $p$ und $q$, beispielsweise mit einer Länge
          von 512 oder 1024 Bit.
    \item Berechne $N = p \cdot q$.
    \item Berechne $\phif{N} = \phif{p \cdot q} = \phif{p} \cdot \phif{q} = (p-1) \cdot (q-1)$.
    \item Wähle eine Zahl $e$ mit $1 < e < N$ und $\ggt{e}{\phif{N}} = 1$. Jetzt bilden
          $(N,e)$ den öffentlichen Schlüssel $(\keypub)$.
    \item Berechne $d$ mit $e \cdot d \equiv 1 \pmod{\phif{N}}$ und dem erweiterten
          Euklidischen Algorithmus. Das Inverse existiert, denn es gilt $e \perp \phif{N}$.
          Jetzt bilden $(N,d)$ den privaten Schlüssel $(\keypr)$.
  \end{enumerate}
\end{definition}

\noindent
Sind $p$ und $q$ entsprechend groß, ist es nicht in annehmbarer Zeit möglich, die Faktorisierung
von $N$ zu bestimmen und damit auch $\phif{N}$. Die Ver- und Entschlüsselung mit RSA
gestaltet sich sehr einfach:

\begin{definition}[Das RSA-Verfahren]
  Es seien der öffentliche und private Schlüssel gegeben mit
  $\keypub = (N,e)$ und $\keypr = (N,d)$. Dann gilt
  \begin{description}
    \item[Verschlüsselung:] $y = e_{\keypub}(x) \equiv x^e \pmod{N}$
    \item[Entschlüsselung:] $x = d_{\keypr}(y) \equiv y^d \pmod{N}$
  \end{description}
  mit $x,y \in \mathbb{Z}_N$.
\end{definition}

\noindent
Bevor die Korrektheit von RSA bewiesen wird, schreiben wir noch einen Satz auf, welcher im
Beweis verwendet werden kann:

\begin{satz}
  \label{satz:composite-mod}
  $m$ ist eine zusammengesetzte Zahl der Form $m = k_1 \cdot k_2 \cdot \ldots \cdot k_n$, dann
  ist $a \equiv b \pmod{m}$, wenn gilt:
  \begin{equation*}
    a \equiv b \pmod{k_1} \quad\ldots\quad a \equiv b \pmod{k_n}
  \end{equation*}
\end{satz}
\begin{proof}
  Die eben gezeigten Kongruenzen lassen sich als Gleichungen schreiben:
  \begin{align*}
    a - b & = t_0 \cdot m   \\
    a - b & = t_1 \cdot k_1 \\
    \vdots                  \\
    a - b & = t_n \cdot k_n
  \end{align*}
  Wobei $t_i$ irgendwelche ganzen Zahlen sind. Es lässt sich schreiben:
  \begin{equation*}
    t_0 \cdot m = t_1 \cdot k_1 = \ldots = t_n \cdot k_n
  \end{equation*}
  Man wählt jetzt
  \begin{equation*}
    t_1 = \frac{t_0m}{k_1} \quad\ldots\quad t_n = \frac{t_0m}{k_n}
  \end{equation*}
  und findet immer eine Lösung.
\end{proof}

\noindent
Es soll nun Bewiesen werden, warum das RSA-Verfahren funktioniert:

\begin{proof}
  Die Entschlüsselung des Geheimtextes muss erneut den Klartext ergeben.
  \begin{equation}
    \label{eq:proof-rsa-3.5}
    d_{\keypr}(e_{\keypub}(x)) = x \equiv x^{ed} \pmod{N} \tag{$*$}
  \end{equation}
  Wir wissen per Definition:
  \begin{align}
    e \cdot d & \equiv 1 \pmod{\phif{N}} \notag                           \\
    \label{eq:proof-rsa-3.6}
    e \cdot d & = t \cdot \phif{N} + 1 \qquad t \in \mathbb{Z} \tag{$**$}
  \end{align}
  Um $x \equiv x^{ed} \pmod{pq}$ zu zeigen, reicht es nach \eqref{satz:composite-mod}
  die Faktoren einzeln zu betrachten.
  \begin{enumerate}
    \item Um $x \equiv x^{ed} \pmod{p}$ zu beweisen, betrachten wir zwei Fälle:
          \begin{enumerate}[topsep=0pt]
            \item Es gilt $p \mid x$ und es folgt:
                  $x \equiv 0 \pmod{p}$ woraus folgt $x^{ed} \equiv 0 \equiv x \pmod{p}$
            \item Es gilt $p \nmid x \Rightarrow p \perp x$, einsetzen von \eqref{eq:proof-rsa-3.6} in
                  \eqref{eq:proof-rsa-3.5}
                  und umformen:
                  \begin{equation*}
                    x^{ed} \equiv x^{t\phif{N} + 1} \equiv
                    x^{t\phif{N}} \cdot x \equiv
                    x^{t(p - 1)(q - 1)} \cdot x \equiv
                    (x^{p - 1})^{t(q - 1)} \cdot x \pmod{p}
                  \end{equation*}
                  Nach dem Kleinen Satz von Fermat ist jetzt zu sehen:
                  \begin{equation*}
                    x \equiv (x^{p - 1})^{t(q - 1)} \cdot x \equiv
                    1^{t(q - 1)} \cdot x \equiv x \pmod{p}
                  \end{equation*}
          \end{enumerate}
    \item Die Überlegung für $q$ kann analog durchgeführt werden. Es müssen hierfür
          alle $p$ und $q$ vertauscht werden. \qedhere
  \end{enumerate}
\end{proof}

\begin{example}\mbox{}
  \begin{enumerate}
    \item Wähle $p = 3$ und $q = 11$.
    \item Berechne $N = 33$.
    \item Berechne $\phif{33} = (3 - 1) \cdot (11 - 1) = 20$.
    \item Wähle $e = 3$.
    \item Berechne $d$ mit dem erweiterten Euklidischen Algorithmus:
          \begin{center}
            \begin{tabular}{|l|l|l|l|l|l|}
              \hline
              $a$ & $b$ & $q$ & $r$ & $x$ & $y$                     \\ \hline
              20  & 3   & 6   & 2   & -1  & $1 + 1 \cdot 6 = 7 = d$ \\ \hline
              3   & 2   & 1   & 1   & 1   & $0 - 1 \cdot 1 = -1$    \\ \hline
              2   & 1   & 2   & 0   & 0   & 1                       \\ \hline
            \end{tabular}
          \end{center}
          Das Ergebnis stimmt, denn es gilt $e \cdot d = 3 \cdot 7 = 21 \equiv 1 \pmod{20}$.
    \item Alice kennt den öffentlichen Schlüssel $\keypub = (N,e) = (33,3)$ und kann eine
          Nachricht $x = 4$ verschlüsseln mit $y = x^e = 4^3 \equiv 31 \pmod{33}$
    \item Bob kennt den privaten Schlüssel $\keypr = (N,d) = (33,7)$ und kann die Nachricht
          entschlüsseln mit $y^d = 31^7 \equiv (-2)^7 \equiv (-2)^5 \cdot 2^2 \equiv
            1 \cdot 4 \equiv 4 = x \pmod{33}$. \qedhere
  \end{enumerate}
\end{example}