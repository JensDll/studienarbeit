\chapter{Das RSA-Kryptosystem}
Das RSA-Kryptosystem ist eines der bekanntesten und meist
verbreiteten asymmetrischen Verschlüsselungsverfahren. Es ist benannt nach
den drei Erfindern Ronald Rivest, Adi Shamir und Leonard Adleman, welche das Verfahren
im Jahr 1977 veröffentli\-chten \parencite[173]{BOOK:crypto}. In diesem Kapitel
sollen die Ideen von asymmetrischer Verschlüsselung
(engl. \textit{public-key-crpytography} oder \textit{asymmetric crpytography})
vorgestellt werden. Es wird hierbei genauer auf das RSA-Kryptosystem eingegangen und
es werden einige zahlentheoretischen Grundlagen gezeigt.

\section{Asymmetrische Verschlüsselung}
Um die Idee der asymmetrischen Verschlüsselung besser zu verstehen,
ist es hilfreich auf das Prinzip der symmetrischen Verfahren zurückzukommen
(\autoref{fig:sym-encryption-revisit}).

\input{kapitel/rsa/tikz/sym-encryption.tex}

\noindent
Ein solches System hat zwei symmetrische Eigenschaften:
\begin{enumerate}
  \item Der selbe geheime Schlüssel wird sowohl für die
        Verschlüsselung als auch Entschlüsselung verwendet.
  \item Die Ver- und Entschlüsselungsfunktion sind sich sehr ähnlich
        (im Fall von \acs{otp} oder \acs{des} sind sie sogar gleich).
\end{enumerate}
Symmetrische Verfahren wie \acs{aes} sind sehr sicher und schnell,
jedoch kommen sie nicht ohne Defizite, wie im Folgenden beschrieben wird.

\paragraph{Schlüsselverteilungsproblem}
Da beide Parteien den selben Schlüssel benötigen, muss dieser in
irgendeiner Form untereinander verteilt werden.
Der direkte Austausch über die Schnittstelle ist nicht möglich, denn
die öffentliche Kommunikationsstrecke (unsicherer Kanal) ist nicht geschützt gegen Abhören.

\paragraph{Anzahl der Schlüssel}
Auch wenn das Schlüsselverteilungsproblem gelöst werden kann, entstehen
schnell Probleme, da die Anzahl der Schlüssel in einem
Netz mit zunehmender Teilnehmerzahl stark wächst. In einem Netz mit $n$
Teilnehmern, wobei jeder Teilnehmer mit jedem verschlüsselt kommunizieren soll, gibt es
\begin{equation*}
  \binom{n}{2} = \frac{n!}{2! \cdot (n-2)!} = \frac{n\cdot(n-1)}{2} \approx \frac{n^2}{2}
\end{equation*}
verschiedene Schlüsselpaare und jeder Teilnehmer muss $n-1$ Schlüssel speichern.
\begin{example}
  In einem Netz mit 500 Teilnehmern gibt es bereits $500 \cdot 499 / 2 = 124.750$ Schlüsselpaare
  und $500 \cdot 499 = 249.500$ Schlüssel müssen verteilt werden.
\end{example}
\noindent
Das Problem ist auch bekannt als das
$n^2$-Schlüsselverteilungsproblem \parencite[334-335]{BOOK:crypto}.

\paragraph{Schutz vor Betrug von Alice und Bob}
Es ist nur mit symmetrischer Verschlüsselung nicht möglich, einer dritten Person
zu beweisen, welcher Gesprächsteilnehmer eine Nachricht erstellt hat.
Es gibt jedoch viele Bereiche in denen dieser Beweis wichtig ist, beispielsweise
im Onlinehandel.
\begin{example}
  Alice betreibt einen Onlinehandel, sie muss beweisen können, dass ein
  Käufer Bob eine Bestellung wirklich getätigt hat, anderenfalls könnte Bob jederzeit behaupten,
  Alice hätte seine Bestellung fälschlicherweise erstellt.
\end{example}
\noindent
Der Begriff um dies zu verhindern nennt sich Non-Repudiation \parencite{SITE:nonrepudiation}
und kann erreicht werden durch digitale Signaturen.
\par
Asymmetrische Verschlüsselungsverfahren bieten mögliche Lösungen zu den eben
beschriebenen Problemen, um eine Nachricht zu verschlüsseln ist es nicht mehr nötig,
dass der Absender in Besitz eines geheimen Schlüssels ist. Um solch ein System zu
realisieren veröffentlicht Bob einen öffentlichen Schlüssel. Dieser steht jedem Netzteilnehmer
zur Verfügung und kann frei verwendet werden.
Bob hat außerdem einen privaten Schlüssel, welchen nur er kennt.
Bob's Schlüssel $k$ besteht also aus einem öffentlichen Teil, $\keypub{}$ (\textit{key public}),
und einem private Teil, $\keypr{}$ (\textit{key private}). Wichtig ist, dass eine Nachricht
welche mit Bob's öffentlichen Schlüssel verschlüsselt wurde, nur auch mit Bob's privaten
Schlüssel wieder entschlüsselt werden kann. Ein einfaches Protokoll
welches nach diesem Prinzip arbeitet ist in \autoref{fig:asym-encr} zu sehen.

\input{kapitel/rsa/tikz/asym-encryption.tex}

\noindent
Ein Nachrichtenaustausch ist somit ohne sicheren Kanal möglich. Der oben beschriebene
Ablauf kann nun so modifiziert, um einen symmetrischen Schlüssel auszutauschen, beispielsweise
für \acs{aes}. Alice generiert einen symmetrischen Schlüssel und verschlüsselt ihn mit einem
asymmetrischen Verfahren. Bob kann die Nachricht entschlüsseln und ist somit ebenfalls
im Besitz des Schlüssels. Wie in \autoref{fig:asym-encr-key-exchange} zu sehen ist,
kann die restliche Kommunikation jetzt mit einem symmetrischen
Verfahren gesichert werden. Es ist wünschenswert nicht dauerhaft asymmetrisch
zu verschlüsseln, da dies im Gegensatz zu dem symmetrischen Gegenstück sehr viel
rechenintensiver ist.
\newpage

\input{kapitel/rsa/tikz/asym-encrpytion-key.tex}

\noindent
Asymmetrische Verfahren basieren alle auf einem zugrundeliegenden Prinzip:
Der Einwegfunktion oder auch Falltürfunktion genannt. Es kann folgende
Definition gegeben werden \parencite[153]{BOOK:crypto}:

\begin{definition}[Einwegfunktion]
  Eine Funktion $f$ ist eine Einwegfunktion, wenn gilt:
  \begin{enumerate}
    \item Der Funktionswert $y = f(x)$ ist komplexitätstheoretisch einfach berechenbar,
          d.h. die Laufzeit des Algorithmus wächst
          nicht stärker als eine Polynomfunktion (Polynomialzeit).
    \item Die Umkehrfunktion $x = f^{-1}(y)$ ist komplexitätstheoretisch schwierig berechenbar,
          d.h. es gibt keinen bekannten Algorithmus welcher das Problem in angemessener
          Zeit lösen kann, zum Beispiel in 1000 Jahren.
  \end{enumerate}
\end{definition}

\noindent
Es gibt zwei Einwegfunktionen welche in der Praxis häufig eingesetzt werden.
Die erste Funktion, welche in RSA verwendet wird,
basiert auf dem Faktorisieren großer natürlicher Zahlen.
Es ist einfach ein Produkt zu berechnen, jedoch ist es schwierig eine Zahl zu
faktorisieren. Die zweite Funktion basiert auf dem Lösen diskreter Logarithmen.
Das Lösen diskreter Logarithmen ist schwierig, das gesamte Verfahren
hat jedoch keine so intuitive Beschreibung.

\section{Zahlentheoretische Grundlagen für RSA}
In diesem Abschnitt sollen die zahlentheoretischen Grundlagen beschrieben werden,
welche im RSA-Kryptosystem zum Einsatz kommen.

\subsection{Der Euklidische Algorithmus}
Es wird begonnen mit dem Begriff des größten gemeinsamen Teiler.
Es seien $a,b \in  \mathbb{N}$, es bezeichnet $T(a)$ die Menge aller Teiler von $a$,
dann heißt jedes $t \in T(a) \cap T(b)$ gemeinsamer Teiler von $a$ und $b$.

\begin{example}
  \begin{align*}
    T(6)           & = \{1,2,3,6\} \\
    T(4)           & = \{1,2,4\}   \\
    T(6) \cap T(4) & = \{1,2\}
  \end{align*}
\end{example}

\begin{definition}[Größter gemeinsamer Teiler]
  Es seien $a,b \in \mathbb{N}$.\\
  Es sei $T = T(a) \cap T(b)$.\\
  Es sei $g \in T$ und es gelte für alle $t \in T$: $t \leq g$. Dann heißt $g$
  größter gemeinsamer Teiler von $a$ und $b$.
  Man schreibt auch $g = \ggt{a}{b}$.
\end{definition}

\paragraph{Rechenregeln für ggT:}
Für $a,b \in \mathbb{N}$ gilt \parencite{SITE:euklid}:
\begin{enumerate}[ref=(\arabic*)]
  \item $\ggt{a}{a} = a$ \label{enum:ggT1}
  \item $\ggt{a}{1} = 1$ \label{enum:ggT2}
  \item $\ggt{a}{0} = a$ \label{enum:ggT3}
  \item $\ggt{a}{b} = \ggt{b}{a}$ \label{enum:ggT4}
  \item $\ggt{a}{b} = \ggt{a - b}{b}$ \label{enum:ggT5}
\end{enumerate}

\begin{proof}\mbox{}
  \begin{enumerate}
    \item Wegen $T(a) \cap T(a) = T(a)$.
    \item Wegen $T(1) = \{1\}$ und $T(a) \cap \{1\} = \{1\}$.
    \item Wegen $T(0) = \mathbb{N}$ und $T(a) \cap \mathbb{N} = T(a)$.
    \item Wegen der Kommutativität der Schnittmenge $T(a) \cap T(b) = T(b)\cap T(a)$.\newpage
    \item Zu zeigen: $\ggt{a}{b} = \ggt{a - b}{b}$ geschrieben als $g = g'$.
          \begin{center}
            Aus $g|a$ und $g|b \Rightarrow g|a-b \Rightarrow g \in T(a-b) \cap T(b)$.\\
            $g$ ist wie $g'$ gemeinsamer Teiler von $a-b$ und $b$.
          \end{center}
          Ist $g$ der größte gemeinsame Teiler?
          Es sei $x \in T(a-b) \cap T(b)$ und $x > \ggt{a}{b}$:
          \begin{center}
            Aus $x|a-b$ und $x|b \Rightarrow x|a$.\\
            $x|a$ und $x|b$ und $x > \ggt{a}{b}$ führt zum Wiederspruch.
          \end{center}
  \end{enumerate}
\end{proof}

\begin{example}
  Es seien $a=132$ und $b=51$, dann gilt:
  \begin{align*}
    \ggt{132}{51} & \numeq{\ref{enum:ggT5}} \ggt{132 - 51}{51} =
    \ggt{81}{51} \numeq{\ref{enum:ggT5}} \ggt{30}{51} \numeq{\ref{enum:ggT5}}
    \ggt{30}{21} \numeq{\ref{enum:ggT5}}                                        \\
    \ggt{9}{21}   & \numeq{\ref{enum:ggT5}} \ggt{9}{12} \numeq{\ref{enum:ggT5}}
    \ggt{9}{3} \numeq{\ref{enum:ggT5}} \ggt{6}{3} \numeq{\ref{enum:ggT5}}
    \ggt{3}{3} \numeq{\ref{enum:ggT1}} 3
  \end{align*}
\end{example}

\noindent
Es ist zu sehen, dass sich Rechenregel \ref{enum:ggT5} iterativ anwenden lässt:
\begin{equation*}
  \ggt{a}{b} = \ggt{a-b}{a} = \ggt{a-2b}{b} = \dots = \ggt{a-mb}{b}
\end{equation*}
Wird ein maximales $m$ gewählt, mit der Bedingung $(a-mb) > 0$, kann der Algorithmus
in minimalen Schritten durchgeführt werden. Dies ist der Fall für die Division mit Rest:
\begin{equation*}
  \ggt{a}{b} = \ggt{a \mod{b}}{b}
\end{equation*}

\begin{example}
  Es seien $a=132$ und $b=51$, dann gilt:
  \begin{align*}
    a   & = q \cdot b + r   &               &                  \\
    132 & = 2 \cdot 51 + 30 & \ggt{132}{51} & = \ggt{51}{30}   \\
    51  & = 1 \cdot 30 + 21 & \ggt{51}{30}  & = \ggt{30}{21}   \\
    30  & = 1 \cdot 21 + 9  & \ggt{30}{21}  & = \ggt{21}{9}    \\
    21  & = 2 \cdot 9 + 3   & \ggt{21}{9}   & = \ggt{9}{3}     \\
    9   & = 3 \cdot 3 + 0   & \ggt{9}{3}    & = \ggt{3}{0} = 3
  \end{align*}
\end{example}
\noindent
In allgemeiner Form können die eben gezeigten Schritte folgendermaßen beschrieben werden:
\begin{equation}
  \label{eq:euklid}
  \begin{split}
    a_i     & = q_i \cdot b_i + r_i \\
    a_{i+1} & = q_{i+1} \cdot b_{i+1} + r_{i+1} \\
    \text{mit} \quad a_{i+1} & = b_i \\
    b_{i+1} & = r_i = a_i - q_i \cdot b_i
  \end{split}
\end{equation}
Eine formale Beschreibung des Algorithmus ist in \autoref{lst:euklid} zu sehen.
% \begin{lstlisting}[ caption=Der Euklidische Algorithmus, label=lst:euklid]
% int ggt(int a, int b)
% {
%   while (true)
%   {
%     int r = a % b;

%     if (r == 0)
%     {
%       return b;
%     }

%     a = b;// $a_{i+1} = b_i$
%     b = r;
%   }
% }
% \end{lstlisting}
\begin{lstlisting}[caption=Der Euklidische Algorithmus, label=lst:euklid]
§
\textbf{Eingabe:}\quad $a_0,b_0 \in \mathbb{N}$ mit $a_0 > b_0$\\
\textbf{Ausgabe:}\quad $\ggt{a_0}{b_0}$\\
\textbf{Initialisierung:}\quad $i = -1$\\
\textbf{Algorithmus:}
§

do
  $i = i + 1$
  $r_i = a_i \mod{b_i}$
  $a_{i+1} = b_i$
  $b_{i+1} = r_i$
while $r_i \neq 0$
return
  $\ggt{a_0}{b_0} = r_{i-1}$
\end{lstlisting}

\subsection{Der erweiterte Euklidische Algorithmus}
Es wurde gezeigt, dass der größte gemeinsame Teiler zweier Zahlen durch
das Reduzieren der Operanden ermittelt werden kann. In der Kryptographie ist
das Finden dieser Zahl allerdings nicht das Hauptanwendungsgebiet des
Algorithmus. Es stellt sich heraus, dass eine Erweiterung des Euklidischen Algorithmus
verwendet werden kann, um multiplikative Inverse Modulo $m$ zu ermitteln.
Betrachtet man den Ring $\mathbb{Z}_m$, dann ist das Inverse $a^{-1}$
einer Zahl $a \in \mathbb{Z}_m$ gegeben durch die folgende Beziehung:
\begin{equation}
  \label{eq:inverse}
  a \cdot a^{-1} \equiv 1 \mod{m}
\end{equation}
Das multiplikative Inverse existiert nicht für alle Elemente. Es kann aber eine Aussage
darüber getroffen werden, wann es existiert. Eine Element
$a \in \mathbb{Z}_m$ besitzt genau dann ein Inverses, wenn gilt $\ggt{a}{m} = 1$.
Zwei Zahlen $a$ und $b$ für die gilt $\ggt{a}{b} = 1$ nennt man teilerfremd oder
relativ Prim (engl. \textit{relatively prime} oder \textit{coprime}).
Der Erweiterte Euklidische Algorithmus berechnet eine Linearkombination der folgenden Form,
welche auch als diophantische Gleichung
bezeichnet wird \parencite[160]{BOOK:crypto} \parencite{SITE:diophant}:
\begin{equation*}
  a \cdot x + b \cdot y = \ggt{a}{b}
\end{equation*}

\begin{example}
  Es seien erneut $a=132$ und $b=51$, es wird zuerst der $\ggt{132}{51}$ mit dem
  Euklidischen Algorithmus bestimmt:
  \begin{align*}
    132 & = 2 \cdot 51 + 30 \\
    51  & = 1 \cdot 30 + 21 \\
    30  & = 1 \cdot 21 + 9  \\
    21  & = 2 \cdot 9 + 3   \\
    9   & = 3 \cdot 3 + 0
  \end{align*}
  Der $\ggt{132}{51}$ ist mit 3 bestimmt. Es soll nun versucht werden, ein $x$ und $y$
  zu finden, so dass $3 = 132 \cdot x + 51 \cdot y$. Aus der vorletzten Zeile weiß man:
  \begin{equation*}
    3 = 21 - 2 \cdot 9
  \end{equation*}
  Wie kam die 9 zustande? Aus der Zeile darüber mit $9 = 30 - 21$.
  Eingesetzt und zusammengefasst:
  \begin{equation*}
    3 = 21 - 2 \cdot (30 - 21) = 21 - 2 \cdot 30 + 2 \cdot 21 = -2 \cdot 30 + 3 \cdot 21
  \end{equation*}
  Wie kam die 21 zustande? Erneut aus der Zeile darüber mit $21 = 51 - 30$.
  Eingesetzt, zusammengefasst und für die letzten beiden Zeilen fortgeführt:
  \begin{align*}
    3 & = -2 \cdot 30 + 3 \cdot (51 - 30) =
    -2 \cdot 30 + 3 \cdot 51 - 3 \cdot 30 = 3 \cdot 51 - 5 \cdot 30                          \\
    3 & = 3 \cdot 51 - 5 \cdot (132 - 2 \cdot 51) = 3 \cdot 51 - 5 \cdot 132 + 10 \cdot 51 =
    -5 \cdot 132 + 13 \cdot 51
  \end{align*}
  Man erhält die gewünschte Gleichung.
\end{example}

\noindent
Das Verfahren kann erneut allgemein betrachtet werden. Durch Rückwärtsarbeiten erhält
man verschiedene Gleichungen der folgenden Form:
\begin{align*}
  \ggt{a}{b} & = x_i \cdot a_i + y_i \cdot b_i                 \\
  \ggt{a}{b} & = x_{i+1} \cdot a_{i+1} + y_{i+1} \cdot b_{i+1}
\end{align*}
Außerdem kennen wir die Gleichungen aus \ref{eq:euklid}:
\begin{align*}
  a_i                      & = q_i \cdot b_i + r_i             \\
  a_{i+1}                  & = q_{i+1} \cdot b_{i+1} + r_{i+1} \\
  \text{mit} \quad a_{i+1} & = b_i                             \\
  b_{i+1}                  & = r_i = a_i - q_i \cdot b_i
\end{align*}
Einsetzen und umformen:
\begin{align*}
  \ggt{a}{b} & = x_i \cdot a_i + y_i \cdot b_i                               \\
             & = x_i \cdot (q_i \cdot b_i + r_i) + y_i \cdot a_{i+1}         \\
             & = x_i \cdot (q_i \cdot a_{i+1} + b_{i+1}) + y_i \cdot a_{i+1} \\
             & = x_i \cdot b_{i+1} + (y_i + x_i \cdot q_i) \cdot a_{i+1}
\end{align*}
Es ergeben sich die folgenden Regeln:
\begin{align}
  x_i & = y_{i+1} \\
  \begin{split}
    y_i + x_i \cdot q_i &= x_{i+1} \\
    y_i &= x_{i+1} - x_i \cdot q_i \\
    y_i &= x_{i+1} - y_{i+1} \cdot q_i
  \end{split}
\end{align}
Dies resultiert im erweiterten Euklidischen Algorithmus, welcher in Tabellenform
einfach und schnell durchführbar ist:

\begin{table}[h]
  \caption{Erweiterter Euklidischer Algorithmus}
  \centering
  \begin{tabular}{|l|l|l|l|l|l|l|l|}
    \hline
    $i$ & $a$ & $b$ & $q$ & $r$ & $x$ & $y$                   & Kontrolle                        \\ \hline
    0   & 132 & 51  & 2   & 30  & -5  & $3 +5 \cdot 2 = 13$   & $3 = -5 \cdot 132 + 13 \cdot 51$ \\ \hline
    1   & 51  & 30  & 1   & 21  & 3   & $-2 - 3 \cdot 1 = -5$ & $3 = 3 \cdot 51 - 5 \cdot 30$    \\ \hline
    2   & 30  & 21  & 1   & 9   & -2  & $1 + 2 \cdot 1 = 3$   & $3 = -2 \cdot 30 + 3 \cdot 21$   \\ \hline
    3   & 21  & 9   & 2   & 3   & 1   & $0 - 1 \cdot 2 = -2$  & $3 = 1 \cdot 21 - 2 \cdot 9$     \\ \hline
    4   & 9   & 3   & 3   & 0   & 0   & 1                     & $3 = 0 \cdot 9 + 1 \cdot 3$      \\ \hline
  \end{tabular}
\end{table}

\noindent
Es soll nun gezeigt werden, wie der erweiterte Euklidischen Algorithmus verwendet werden kann
um multiplikative Inverse zu berechnen. Es soll das Inverse $a \mod{m}$ bestimmt werden, wobei
$m > a$. Das Inverse existiert genau dann, wenn \ggt{m}{a} = 1, dies bedeutet es gibt
eine Gleichung der Form $x \cdot m + y \cdot a = 1$. Stellt man diese Gleichung
als Kongruenzrelation Modulo $m$ dar, erhalten wir:
\begin{align*}
  x \cdot m + y \cdot a & = 1              \\
  x \cdot m + y \cdot a & \equiv 1 \mod{m} \\
  x \cdot 0 + y \cdot a & \equiv 1 \mod{m} \\
  a \cdot y             & \equiv 1 \mod{m}
\end{align*}
Die letzte Zeile ist genau die Definition des Inversen (\ref{eq:inverse}), welches
mit $y$ bestimmt wurde.
\begin{example}
  Es soll das Inverse $21^{-1} \mod{89}$ bestimmt werden. Die Zahlen 21 und 89 sind
  teilerfremd, d.h. das Inverse existiert und es gilt
  $\ggt{89}{21} = 1 = x \cdot 89 + y \cdot 21$. Der Euklidische
  Algorithmus kann tabellarisch durchgeführt werden:
  \begin{center}
    \centering
    \begin{tabular}{|l|l|l|l|l|l|l|}
      \hline
      $i$ & $a$ & $b$ & $q$ & $r$ & $x$ & $y$                  \\ \hline
      0   & 89  & 21  & 4   & 5   & -4  & $1 + 4 \cdot 4 = 17$ \\ \hline
      1   & 21  & 5   & 4   & 1   & 1   & $0 - 1 \cdot 4 = -4$ \\ \hline
      2   & 5   & 1   & 5   & 0   & 0   & 1                    \\ \hline
    \end{tabular}
  \end{center}
  \noindent
  Wir erhalten den größten gemeinsamen Teiler als Linearkombination:
  \begin{equation*}
    -4 \cdot 89 + 17 \cdot 21 = 1
  \end{equation*}
  Es folgt hieraus: Das Inverse von 21 in $\mathbb{Z}_{89}$ beträgt 17, dieses Ergebnis kann durch nachrechnen
  verifiziert werden:
  \begin{equation*}
    17 \cdot 21 = 357 \equiv 1 \mod{89}
  \end{equation*}
\end{example}