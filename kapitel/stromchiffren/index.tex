\chapter{Stromchiffren}

\input{kapitel/stromchiffren/tikz/cryptographie.tex}

\noindent
Werfen wir in \autoref{fig:sym-ciphers-overview} einen genaueren Blick auf die Algorithmen
der Kryptographie, stellen wir fest: Das Gebiet
der symmetrischen Verschlüsselungsverfahren kann unterteilt werden in Strom- und Blockchiffren.
In diesem Kapitel soll die Funktionsweise von Stromchiffren untersucht und der Unterschied zu
den Blockchiffren erläutert werden. Außerdem wird gezeigt welche
Rolle hierbei die Zufallszahlengeneratoren spielen.

\section{Stromchiffren und Blockchiffren}
Die symmetrischen Verschlüsselungsverfahren sind unterteilt in Strom- und Blockchiffren.
Während beide Verfahren das Ziel haben Informationen zu verschlüsseln, ist die jeweilige
Methode eine unterschiedliche. Stromchiffren verschlüsseln jedes Bit im Klartext einzeln,
während Blockchiffren pro Durchlauf mehrere Bits verschlüsseln können.
\autoref{fig:stream-vs-block-cipher} zeigt diesen prinzipiellen Unterschied, für den Fall, dass
$n$ Bits verschlüsselt werden sollen.

\input{kapitel/stromchiffren/tikz/principle-encryption-stream.tex}

\noindent
Blockchiffren arbeiten mit Datenblöcken fester Länge, wobei ein Großteil der
relevanten Algorithmen eine Eingangsweite von 64 oder 128 Bits besitzen.
Prominente Beispiele sind Verfahren wie der Data Encryption Standard
(DES, Blocklänge 64 Bit, \cite[55-58]{BOOK:crypto}) oder der Advanced Encryption Standard
(AES, Blocklänge 128 Bit, \cite[87-90]{BOOK:crypto}).
Generell lassen sich die folgenden drei Punkte zusammenfassen \parencite[31]{BOOK:crypto}:

\begin{enumerate}[itemsep = 0pt]
  \item Blockchiffren werden in der Praxis, vor allem für die Verschlüsselung im Internet,
        häufiger eingesetzt als Stromchiffren.
  \item Stromchiffren sind oft klein und schnell und deshalb attraktiv für Anwendungen,
        bei denen vergleichsweise wenig Rechenleistung zur Verfügung steht, beispielsweise bei
        Mobilgeräten oder anderen eingebetteten Systemen. Ein bekanntes Verfahren ist der
        A5/1 Algorithmus, welcher Teil des GSM-Mobilfunkstandards ist und die Gesprächsdaten
        an der Luftschnittstelle verschlüsselt. A5/1 gilt aufgrund der kurzen Schlüssellänge von
        64 Bit nicht mehr als uneingeschränkt sicher, erschwert aber dennoch das einfache Abhören.
  \item In der Vergangenheit galt der generelle Gedanke, dass Stromchiffren
        effizienter seien als Blockchiffren.
        Im Allgemeinen gilt diese Annahme heutzutage jedoch nicht mehr. Moderne Verfahren wie AES
        können sowohl in Hardware als auch Software sehr effizient implementiert werden.
\end{enumerate}

\newpage
\section{Die Ver- und Entschlüsselung mit Stromchiffren}
Wie oben erwähnt, verschlüsseln Stromchiffren jedes Bit im Klartext einzeln. Hierfür
wird durch einen Schlüssel ein geheimer Bitstrom errechnet, welcher paarweise mit den Bits
des Klartextes kombiniert wird. Die Ver- und Entschlüsselung ist verblüffend einfach, es handelt
sich in beide Richtungen um eine einfache Addition im Ring $\mathbb{Z}_2$.

\begin{definition}[{Ver- und Entschlüsselung mit Stromchiffren, \cite[31]{BOOK:crypto}}]
  Es seien $x_i,y_i,s_i \in \{0,1\}$ die einzelnen Bits aus Klartext, Geheimtext und Schlüs\-selstrom.
  Es gilt:
  \begin{description}[itemsep = 0pt]
    \item[Verschlüsselung:] $y_i = e_{s_i}(x_i) \equiv x_i + s_i \mod{2}$
    \item[Entschlüsselung:] $x_i = d_{s_i}(y_i) \equiv y_i + s_i \mod{2}$
  \end{description}
\end{definition}

\noindent
Betrachtet man die Ver- und Entschlüsselungsfunktion, fallen drei Aspekte auf welche
besprochen werden müssen \parencite[31-34]{BOOK:crypto}:

\begin{enumerate}[itemsep = 0pt]
  \item Warum ist Verschlüsselung und Entschlüsselung die selbe Funktion?
  \item Warum ist einfache Addition im Ring $\mathbb{Z}_2$ eine gute Verschlüsselung?
  \item Was sind die Eigenschaften der Schlüsselstrombits $s_i$?
\end{enumerate}

\paragraph{Warum ist Verschlüsselung und Entschlüsselung die selbe Funktion?}\mbox{}\\
Bis auf spezielle Kürzungsregeln erlauben Kongruenzen (ganz analog wie mit Gleichungen)
das Ausführen der elementaren Rechenoperationen \parencite[181-183]{BOOK:numberTheory}.
Mit diesem Wissen kann die Verschlüsselungsfunktion durch einfaches Umformen in die
Entschlüsselungsfunktion überführt werden.
\begin{proof}
  \begin{align*}
    y_i  & \equiv x_i + s_i \mod{2}  \\
    -x_i & \equiv -y_i + s_i \mod{2} \\
    x_i  & \equiv y_i + s_i \mod{2}
  \end{align*}
\end{proof}
\noindent
Im letzten Schritt wird erneut von dem Wechsel innerhalb der Restklasse Gebrauch gemacht,
denn es gilt $-1 \equiv 1 \mod{2}$.

\paragraph{Warum ist einfache Addition im Ring $\mathbb{Z}_2$ eine gute Verschlüsselung?}\mbox{}\\
Das Rechnen in $\mathbb{Z}_2$ liefert aufgrund der Division mit Rest nur Ergebnisse in
der Menge $\{0,1\}$. Dieses Verhalten ist sehr hilfreich, denn es ermöglicht das Ausdrücken der
Arithmetik durch einfache boolesche Algebra.
Betrachtet man die Wahrheitstabelle \ref{tab:truth-table-addition-mod-2}
der Addition in $\mathbb{Z}_2$, kann sofort eine weitere Beobachtung gemacht werden:
Die Addition modulo 2 ist äquivalent zu der Exklusiv-Oder-Verknüpfung durch ein XOR-Gatter.

\begin{table}[h]
  \centering
  \caption{Wahrheitstabelle der Addition modulo 2}
  \begin{tabular}{cc|c}
    $x_i$ & $s_i$ & $y_i \equiv x_i + s_i \mod{2}$ \\ \hline
    0     & 0     & 0                              \\
    0     & 1     & 1                              \\
    1     & 0     & 1                              \\
    1     & 1     & 0                              \\
  \end{tabular}
  \label{tab:truth-table-addition-mod-2}
\end{table}

\noindent
Das XOR-Gatter spielt eine wesentliche Rolle in vielen kryptographischen Verfahren.
Es besitzt besondere Eigenschafen, welche es von anderen Logikgattern
unterscheidet, diese sollen jetzt untersucht werden.
Angenommen es soll das Klartextbit $x_i = 0$ verschlüsselt werden. In der Wahrheitstabelle
des XOR-Gatters befindet man sich demnach in der ersten oder zweiten Zeile:

\begin{table}[h]
  \centering
  \caption{Wahrheitstabelle der Exklusiv-Oder-Verknüpfung}
  \begin{tabular}{cc|c}
    $x_i$      & $s_i$      & $y_i = x_i \oplus s_i$ \\ \hline
    \textbf{0} & \textbf{0} & \textbf{0}             \\
    \textbf{0} & \textbf{1} & \textbf{1}             \\
    1          & 0          & 1                      \\
    1          & 1          & 0                      \\
  \end{tabular}
  \label{tab:truth-table-xor}
\end{table}

\noindent
Je nach Schlüsselbit $s_i$ ist das Geheimtextbit $y_i$ gegeben als
$y_i = 0 \oplus 0 \vee 0 \oplus 1 = 0 \vee 1$.
Verhalten sich die Schlüsselbit unvorhersehbar , d.h. sie sind mit genau 50 prozentiger
Wahrscheinlichkeit entweder null oder eins, ist es nur durch das Chiffrat nicht möglich auf
den Klartext zu schließen. Zu jedem Zeitpunkt hat ein Angreifer nur eine
50 prozentige Chance den richtigen Klartext zu erraten.
Gleichermaßen kann argumentiert werden, sei $x_i = 1$.
Diese Symmetrie unterscheidet das XOR-Gatter von anderen Logikgattern, zusätzlich ist es die einzige
Verknüpfung welche durch doppeltes Anwenden invertierbar ist.
\autoref{fig:enc-dec-stream-cipher} zeigt den Ver- und Entschlüsselungsprozess
bei Stromchiffren.
\newpage

\input{kapitel/stromchiffren/tikz/encryption-stream.tex}

\noindent
In einem Beispiel soll jetzt ein einfacher Informationsaustausch demonstriert werden:

\newcommand{\streamencryption}{
  \begin{aligned}
    x_0,\dots,x_7 = 01010 & 000_2 = 80_{10} = \text{\texttt{P}}  \\
    \oplus                &                                      \\
    s_0,\dots,s_7 = 00111 & 010_2                                \\
    y_0,\dots,y_7 = 01101 & 010_2 = 106_{10} = \text{\texttt{j}}
  \end{aligned}
}

\newcommand{\streamdecryption}{
  \begin{aligned}
    y_0,\dots,y_7 = 01101 & 010_2 = 106_{10} = \text{\texttt{j}} \\
    \oplus                &                                      \\
    s_0,\dots,s_7 = 00111 & 010_2                                \\
    x_0,\dots,x_7 = 01010 & 000_2 = 80_{10} = \text{\texttt{P}}
  \end{aligned}
}

\newcommand{\streamarrow}{\tikz{\draw[->] (0,0) to
    node[above] {$\text{\texttt{j}} = 01101010_2$} (2,0);}}

\begin{example}
  Alice möchte Bob eine Nachricht senden. Sie verschickt den Buchstaben \texttt{P},
  wobei dieser zur Verschlüsselung in
  ASCII-Zeichenkodierung angegeben ist $\text{\texttt{P}} = 80_{10} = 01010000_2$. Der
  Schlüsselstrom wird außerdem angegeben, es seien $(s_0,s_1,\dots,s_7) = 00111010_2$.

  \begin{table*}[h]
    \centering
    \begin{tabular}{lc}
      $\streamencryption$              & \textbf{Alice} \\
                                       &                \\
      \multicolumn{1}{c}{\streamarrow} & \textbf{Oscar} \\
                                       &                \\
      $\streamdecryption$              & \textbf{Bob}
    \end{tabular}
  \end{table*}

  \noindent
  Vor der Übertragung wird der Großbuchstabe \texttt{P} durch die XOR-Verknüpfung
  in den Kleinbuchstaben \texttt{j}
  umgewandelt. Der Gegenspieler Oscar kann mit dieser Information aufgrund der oben beschriebenen
  Eigenschaften nur wenig anfangen.
\end{example}

\noindent
Stromchiffren erscheinen fast zu gut, um wahr zu sein, doch wie gewohnt sind die Dinge in
der Realität nicht immer so einfach. Es bleibt die Letzte der drei Fragestellungen zu
beantworten.
\newpage

\paragraph{Was sind die Eigenschaften der Schlüsselstrombits?}\mbox{}\\
Die Sicherheit von Stromchiffren hängt vollständig von der Qualität des Schlüsselstroms ab.
Das Generieren dieser Bitfolge ($s_1,s_2,\dots,s_n$) bildet die zentrale Fragestellung
der Verschlüsselungsmethode.
Es wurde gezeigt, dass der Schlüsselstrom wie eine zufällige
Bitsequenz aussehen muss. Im nächsten Abschnitt soll deshalb das Thema der
Zufallszahlen diskutiert werden.

\section{Zufallszahlengeneratoren}
Wie oben beschrieben, ist die Unvorhersehbarkeit des Schlüsselstroms die wesentliche
Eigenschaft von Stromchiffren. Im Folgenden sollen deshalb einige
Formen von Zufallszahlengeneratoren (engl. \acp{rng}) vorgestellt
werden \parencite[35-36]{BOOK:crypto} \parencite{SITE:randomorg}.

\paragraph{Echte Zufallszahlengeneratoren}
Echte Zufallszahlengeneratoren (engl. \acp{trng})
erzeugen Zahlen, welche in keiner Weise vorhersehbar und reproduzierbar sind. Notiert man
beispielsweise das Ergebnis von 100 Münzwürfen und erzeugt eine Folge von 100 Bit, ist es quasi
unmöglich, die selbe Sequenz ein zweites Mal zu erzeugen. Die Wahrscheinlichkeit
das dies passieren würde, beträgt $1/2^{100}$, was verschwindend gering ist.
Echte Zufallszahlen basieren auf physikalischen Prozessen. Beispiele umfassen Münzwurf, Würfeln,
radioaktiver Zerfall oder atmosphärisches Rauschen. \acp{trng} werden in der Kryptographie und
der Schlüsselerzeugung häufig eingesetzt.

\paragraph{Pseudozufallszahlengeneratoren}
Pseudozufallszahlengeneratoren (engl. \acp{prng})
generieren Zahlenfolgen basierend auf einem Startwert, welcher im Englischen oft als
\enquote{\textit{seed}} bezeichnet wird. Die Zahlen eines \ac{prng} sind nicht in der Art zufällig,
wie man es erwarten könnte.
Obwohl sie aussehen wie eine wirklich zufällige Folge, werden sie durch
mathematische Formeln errechnet und sind deterministisch, d.h. die selbe Sequenz
kann zu einem späteren Zeitpunkt reproduziert werden.
In der Kryptographie können \acp{prng} aufgrund dieser Eigenschaf
nicht ohne weiteres eingesetzt werden.
Dennoch haben sie außerhalb der Kryptographie weitreichende Anwendungsgebiete,
beispielsweise in der Simulation oder während dem Testen von Software und Hardware.
Determinismus ist in diesen Bereichen oftmals eine gewünschte Eigenschaft.

\paragraph{Kryptographisch sichere Pseudozufallszahlengeneratoren}
Kryptographisch sichere Pseudozufallszahlengeneratoren
(engl. \acp{csprng}) sind \acp{prng} mit
einer speziellen zusätzlichen Eigenschaft: \acp{csprng} sind unvorhersehbar. Grob gesprochen
bedeutet dies, dass es rechentechnisch nicht möglich ist, aus $n$ gegeben Schlüsselstrombits
$s_1,s_2,\dots,s_n$, die folgenden Bits $s_{n+1},s_{n+2},\dots,s_{n+m}$ zu berechnen. Außerdem
soll es zeitlich unmöglich sein, eines der vorherigen Bits $s_{n-1},s_{n-2},\dots,s_{n-m}$ zu
berechnen.

\section{Das One-Time-Pad und praktische Stromchiffren}
Mit den bis hierher eingeführten Ideen zu Stromchiffren und den verschiedenen
Zufallszahlengeneratoren sind alle Teile vorhanden, um ein beweisbar
sicheres Verschlüsselungsver\-fahren zu bauen. Ein System heißt beweisbar sicher,
wenn es trotz unendlich vorhandener Rechenleistung nachweislich nicht gebrochen werden kann.
\citeauthor{BOOK:crypto} haben den Begriff mit folgender Definition
beschrieben \parencite*[36]{BOOK:crypto}:

\begin{definition}[\textit{Unconditional Security}]
  \enquote{\textit{A cryptosystem is unconditionally or in\-formation-theoretically
      secure if it cannot be broken even with infinite computational resources.}}
\end{definition}

\noindent
Das \ac{otp} ist ein solches Verschlüsselungsverfahren, welches dieses Kriterium
erfüllt. Es ist folgendermaßen definiert \parencite[37]{BOOK:crypto}:

\begin{definition}[One-Time-Pad]
  Eine Stromchiffre heißt One-Time-Pad, wenn die folgenden Kriterien eingehalten werden:
  \begin{enumerate}[itemsep=0pt]
    \item Der Schüsselstrom $s_1,s_2,\dots,s_n$ wird durch einen \ac{trng} generiert.
    \item Nur vertrauenswürdige Gesprächspartner kennen den Schüsselstrom.
    \item Jedes Schlüsselstrombit $s_i$ wird nur einmal verwendet.
  \end{enumerate}
  Das One-Time-Pad ist beweisbar sicher.
\end{definition}
\noindent
Zu jedem Bit im Geheimtext gibt es eine Gleichung der Form:
\begin{align*}
  y_0   \equiv x_0 & + s_0 \mod{2} \\
  y_1   \equiv x_1 & + s_1 \mod{2} \\
  \vdots           &
\end{align*}
\noindent
Stammt der Schlüsselstrom von einem \ac{trng} können diese Gleichungen nicht gelöst werden.
Für jedes Geheimtextbit $y_i$ gibt es genau zwei Lösungen mit gleich großer Wahrscheinlichkeit:
\begin{align*}
  y = 0 & \equiv 1_x + 1_s \equiv 0_x + 0_s \mod{2} \\
  y = 1 & \equiv 1_x + 0_s \equiv 0_x + 1_s \mod{2}
\end{align*}
In der Praxis hat das Verschlüsseln mit \ac{otp} natürlich einen Hacken, denn warum sonst
sollten heutzutage andere Verfahren eingesetzt werden?

\input{kapitel/stromchiffren/tikz/key-generation-stream.tex}

\noindent
Als erster Punkt ist die Anforderung eines \ac{trng}, dieser benötigt spezielle
Hardware und ist in der Regel nicht Teil eines Standard Computers.
Der zweite und wahrscheinlich größte Nachteil ist die Handhabung des Schlüsselstroms:
Jedes Schlüsselstrombit $s_i$ wird nur einmal verwendet.
Das One-Time-Pad benötigt somit einen Schlüssel, welcher genauso lang ist
wie die Nachricht selbst. Es wird klar, warum diese Anforderung
selbst bei mittelgroßen Nachrichten problematisch wird, zusätzlich muss nach jeder
Übertragung ein neuer Schlüssel ausgetauscht werden. Die Idee von \ac{otp} ist gut,
jedoch müssen für den praktischen Gebrauch einige Modifikationen vorgenommen werden.
Es wird versucht, den Schüsselstrom, welcher aus einer echt zufälligen Quelle stammt,
durch die Ausgabe eines \ac{csprng} zu ersetzen, wobei der Schlüssel $k$
den Startwert des \ac{prng} bildet. Das Prinzip dieser Idee ist in
\autoref{fig:stream-key-gen} zu sehen. Zu nächst ist wichtig festzuhalten, dass
Stromchiffren nicht beweisbar sicher sind. Es ist allerdings so, dass alle in der
Praxis verwendeten Algorithmen (Stromchiffren, Blockchiffren, asymmetrische
Verfahren), keine informationstheoretische Sicherheit aufweisen \parencite[38]{BOOK:crypto}.
Um den Sicherheitsbegriff realistischer zu gestallten, wird der Angreifer in seiner
Rechenleistung beschränkt, man hofft also, dass ein Verfahren berechenbarkeitstheoretisch
sicher ist. Diese Eigenschaft ist von \citeauthor{BOOK:crypto}
folgendermaßen definiert \parencite*[35]{BOOK:crypto}:

\begin{definition}[\textit{Computational Security}]
  \enquote{\textit{A crpytosystem is computationally secure if the best
      known algorithm for breaking it requires at least $t$ operations.}}
\end{definition}